# 2026-02-05 학습 정리

## 1. Optimistic Update (낙관적 업데이트)

### 설명

서버 응답을 기다리지 않고 사용자 액션 즉시 UI를 업데이트하는 패턴. 서버 요청이 실패하면 이전 상태로 롤백한다.

### 왜 필요한가?

- `invalidateQueries`만 사용하면 서버에서 데이터를 다시 가져오는 동안 UI 업데이트가 지연됨
- 좋아요 버튼처럼 즉각적인 피드백이 필요한 경우 UX가 저하됨

### 코드 예시

```typescript
export const useToggleReviewLike = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ reviewId, isLiked }) => {
      // API 호출
    },

    // 1. 요청 전 즉시 캐시 업데이트
    onMutate: async ({ reviewId, isLiked, shopId }) => {
      // 진행 중인 refetch 취소 (optimistic update 덮어쓰기 방지)
      await queryClient.cancelQueries({ queryKey: ["shops", "detail", shopId] });

      // 이전 데이터 스냅샷 저장 (롤백용)
      const previousData = queryClient.getQueriesData({
        queryKey: ["shops", "detail", shopId],
      });

      // 캐시 즉시 업데이트
      queryClient.setQueriesData({ queryKey: ["shops", "detail", shopId] }, (old) => ({
        ...old,
        reviews: old.reviews.map((review) =>
          review.id === reviewId
            ? {
                ...review,
                isLiked: !isLiked,
                likeCount: isLiked ? review.likeCount - 1 : review.likeCount + 1,
              }
            : review
        ),
      }));

      return { previousData };
    },

    // 2. 실패 시 롤백
    onError: (_, { shopId }, context) => {
      context?.previousData.forEach(([queryKey, data]) => {
        queryClient.setQueryData(queryKey, data);
      });
    },

    // 3. 완료 후 서버 데이터와 동기화
    onSettled: (_, __, { shopId }) => {
      queryClient.invalidateQueries({ queryKey: ["shops", "detail", shopId] });
    },
  });
};
```

### 핵심 포인트

- `onMutate`: 요청 전 캐시를 미리 업데이트, 이전 상태 저장
- `onError`: 실패 시 저장한 이전 상태로 롤백
- `onSettled`: 성공/실패 상관없이 서버 데이터와 동기화

---

## 2. React Query Cache Invalidation

### 설명

캐시된 쿼리 데이터를 무효화하여 다음 접근 시 또는 즉시 최신 데이터를 가져오도록 하는 방법.

### invalidateQueries vs staleTime

| 구분   | invalidateQueries   | staleTime        |
| ------ | ------------------- | ---------------- |
| 용도   | 수동 캐시 무효화    | 자동 신선도 관리 |
| 시점   | mutation 성공 후    | 쿼리 정의 시     |
| 사용처 | 데이터 변경 후 갱신 | 읽기 전용 데이터 |

### Partial Query Key 매칭

```typescript
// sortBy 파라미터에 관계없이 해당 shop의 모든 detail 쿼리 무효화
queryClient.invalidateQueries({ queryKey: ["shops", "detail", shopId] });

// vs 정확한 키 매칭 (sortBy가 다르면 무효화 안됨)
queryClient.invalidateQueries({ queryKey: queryKeys.shops.detail(shopId, sortBy) });
```

---

## 3. Flexbox: flex-1 vs h-full

### 문제 상황

바텀시트에서 `h-full`을 사용했더니 헤더 높이를 고려하지 않아 콘텐츠가 넘침.

### 해결

```tsx
// 문제: h-full은 부모의 100% 높이를 차지 (헤더 무시)
<div className="overflow-y-auto h-full pb-safe">

// 해결: flex-1은 남은 공간만 차지 (헤더 제외)
<div className="flex flex-col h-full">
  <header>...</header>
  <div className="flex-1 overflow-y-auto pb-safe">
```

### 핵심 차이

- `h-full`: 부모의 100% 높이 (형제 요소 무시)
- `flex-1`: flex 컨테이너에서 남은 공간을 차지 (형제 요소 고려)

---

## 4. API 응답 undefined 처리

### 문제 상황

회원탈퇴 API가 `{ success: true }` (data 필드 없음)를 반환하는데, 기존 코드는 `data === undefined`를 에러로 처리.

### 해결

```typescript
// 기존: data가 없으면 에러
if (response.data.data === undefined) {
  throw new Error(errorMessage);
}

// 수정: data가 없으면 null로 처리
const data = response.data.data === undefined ? null : response.data.data;
return transform ? transform(data as T) : (data as T);
```

### 교훈

DELETE 요청처럼 응답 본문이 없는 API는 `{ success: true }` 만 반환할 수 있으므로, `data` 필드가 없는 경우를 정상 케이스로 처리해야 함.

---

## 참고 자료

- [TanStack Query - Optimistic Updates](https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates)
- [TanStack Query - Query Invalidation](https://tanstack.com/query/latest/docs/framework/react/guides/query-invalidation)
